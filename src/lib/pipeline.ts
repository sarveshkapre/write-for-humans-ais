import fs from "node:fs/promises";
import path from "node:path";
import { discoverFiles, ensureEmptyDir } from "./fs.js";
import { toMarkdownFromHtml, toMarkdownFromMd, renderMarkdown } from "./markdown.js";
import { slugFromPath } from "./slug.js";
import { sha256File, sha256String } from "./hash.js";
import { loadQuestions, runEval } from "./eval.js";

type Manifest = Record<string, { sha256: string }>;

export type BuildOptions = {
  inputDir: string;
  outDir: string;
  runEval: boolean;
  safetyRoot?: string;
  force?: boolean;
  generatedAt?: string;
};

type PageOutput = {
  title: string;
  slug: string;
  markdownPath: string;
  markdown: string;
};

function extractTitle(markdown: string, fallback: string): string {
  const lines = markdown.split("\n");
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith("# ")) {
      return trimmed.replace(/^#\s+/, "").trim();
    }
  }
  return fallback;
}

async function buildPages(inputDir: string, outDir: string): Promise<PageOutput[]> {
  const files = await discoverFiles(inputDir);
  const pages: PageOutput[] = [];
  const markdownDir = path.join(outDir, "markdown");
  await fs.mkdir(markdownDir, { recursive: true });

  for (const filePath of files) {
    const ext = path.extname(filePath).toLowerCase();
    const content = await fs.readFile(filePath, "utf-8");
    const tree = ext === ".md" || ext === ".markdown"
      ? await toMarkdownFromMd(content)
      : await toMarkdownFromHtml(content);
    const markdown = await renderMarkdown(tree);
    const slug = slugFromPath(filePath, inputDir);
    const outputPath = path.join(markdownDir, `${slug || "index"}.md`);
    await fs.writeFile(outputPath, markdown, "utf-8");
    pages.push({
      title: extractTitle(markdown, slug || "index"),
      slug,
      markdownPath: outputPath,
      markdown,
    });
  }

  return pages;
}

async function writeLlmsFiles(outDir: string, pages: PageOutput[]): Promise<string[]> {
  const llms = [
    "# llms.txt",
    "",
    "Generated by write-for-humans-ais",
    "",
    "Pages:",
    ...pages.map((page) => `- ${page.title} (markdown/${path.basename(page.markdownPath)})`),
    "",
  ].join("\n");

  const llmsFullBlocks = pages.map((page) => {
    return [
      `# ${page.title}`,
      `Path: markdown/${path.basename(page.markdownPath)}`,
      "",
      page.markdown.trim(),
      "",
      "---",
      "",
    ].join("\n");
  });

  const llmsFull = ["# llms-full.txt", "", ...llmsFullBlocks].join("\n");

  const llmsPath = path.join(outDir, "llms.txt");
  const llmsFullPath = path.join(outDir, "llms-full.txt");
  await fs.writeFile(llmsPath, llms, "utf-8");
  await fs.writeFile(llmsFullPath, llmsFull, "utf-8");
  return [llmsPath, llmsFullPath];
}

async function writeClaims(outDir: string, inputDir: string): Promise<string> {
  const candidate = path.join(inputDir, "claims.jsonld");
  const dest = path.join(outDir, "claims.jsonld");
  try {
    const data = await fs.readFile(candidate, "utf-8");
    await fs.writeFile(dest, data, "utf-8");
  } catch {
    const skeleton = {
      "@context": "https://schema.org",
      "@graph": [],
    };
    await fs.writeFile(dest, JSON.stringify(skeleton, null, 2), "utf-8");
  }
  return dest;
}

async function computeManifest(outDir: string, outputFiles: string[]): Promise<Manifest> {
  const manifest: Manifest = {};
  for (const filePath of outputFiles) {
    const rel = path.relative(outDir, filePath).replace(/\\/g, "/");
    manifest[rel] = { sha256: await sha256File(filePath) };
  }
  return manifest;
}

function fingerprintFromManifest(manifest: Manifest): string {
  const entries = Object.entries(manifest)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([relPath, { sha256 }]) => [relPath, sha256]);
  return sha256String(JSON.stringify(entries));
}

async function writeManifest(outDir: string, manifest: Manifest): Promise<string> {
  const manifestPath = path.join(outDir, "manifest.json");
  await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2) + "\n", "utf-8");
  return manifestPath;
}

async function writeEval(
  outDir: string,
  inputDir: string,
  pages: PageOutput[],
  generatedAt: string,
): Promise<string> {
  const questions = await loadQuestions(inputDir);
  const evalDir = path.join(outDir, "eval");
  await fs.mkdir(evalDir, { recursive: true });
  const reportPath = path.join(evalDir, "report.json");

  if (!questions || questions.length === 0) {
    const emptyReport = {
      generatedAt,
      totalQuestions: 0,
      averageCoverage: null,
      results: [],
    };
    await fs.writeFile(reportPath, JSON.stringify(emptyReport, null, 2) + "\n", "utf-8");
    return reportPath;
  }

  const corpus = pages.map((page) => ({
    path: `markdown/${path.basename(page.markdownPath)}`,
    content: page.markdown,
  }));
  const report = runEval(questions, corpus, generatedAt);
  await fs.writeFile(reportPath, JSON.stringify(report, null, 2) + "\n", "utf-8");
  return reportPath;
}

export async function buildSite(options: BuildOptions): Promise<void> {
  const inputDir = path.resolve(options.inputDir);
  const outDir = path.resolve(options.outDir);

  await ensureEmptyDir(outDir, { inputDir, safetyRoot: options.safetyRoot, force: options.force });
  const generatedAt = options.generatedAt ?? new Date(0).toISOString();

  const pages = await buildPages(inputDir, outDir);
  const outputFiles: string[] = pages.map((p) => p.markdownPath);

  const llmsFiles = await writeLlmsFiles(outDir, pages);
  outputFiles.push(...llmsFiles);

  const claimsFile = await writeClaims(outDir, inputDir);
  outputFiles.push(claimsFile);

  if (options.runEval) {
    const evalReport = await writeEval(outDir, inputDir, pages, generatedAt);
    outputFiles.push(evalReport);
  }

  const baseManifest = await computeManifest(outDir, outputFiles);
  const fingerprint = fingerprintFromManifest(baseManifest);
  const fingerprintPath = path.join(outDir, "build.fingerprint");
  await fs.writeFile(fingerprintPath, `${fingerprint}\n`, "utf-8");

  const fullManifest: Manifest = {
    ...baseManifest,
    [path.relative(outDir, fingerprintPath).replace(/\\/g, "/")]: { sha256: await sha256File(fingerprintPath) },
  };

  const manifestPath = await writeManifest(outDir, fullManifest);
  outputFiles.push(fingerprintPath, manifestPath);

  // Note: build.fingerprint intentionally excludes itself and manifest.json.
}
