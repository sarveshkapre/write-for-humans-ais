import fs from "node:fs/promises";
import path from "node:path";
import { discoverFiles, ensureEmptyDir } from "./fs.js";
import { toMarkdownFromHtml, toMarkdownFromMd, renderMarkdown } from "./markdown.js";
import { slugFromPath } from "./slug.js";
import { sha256File, sha256String } from "./hash.js";
import { loadQuestions, runEval } from "./eval.js";
function extractTitle(markdown, fallback) {
    const lines = markdown.split("\n");
    for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith("# ")) {
            return trimmed.replace(/^#\s+/, "").trim();
        }
    }
    return fallback;
}
async function buildPages(inputDir, outDir) {
    const files = await discoverFiles(inputDir);
    const pages = [];
    const markdownDir = path.join(outDir, "markdown");
    await fs.mkdir(markdownDir, { recursive: true });
    for (const filePath of files) {
        const ext = path.extname(filePath).toLowerCase();
        const content = await fs.readFile(filePath, "utf-8");
        const tree = ext === ".md" || ext === ".markdown"
            ? await toMarkdownFromMd(content)
            : await toMarkdownFromHtml(content);
        const markdown = await renderMarkdown(tree);
        const slug = slugFromPath(filePath, inputDir);
        const outputPath = path.join(markdownDir, `${slug || "index"}.md`);
        await fs.writeFile(outputPath, markdown, "utf-8");
        pages.push({
            title: extractTitle(markdown, slug || "index"),
            slug,
            markdownPath: outputPath,
            markdown,
        });
    }
    return pages;
}
async function writeLlmsFiles(outDir, pages) {
    const llms = [
        "# llms.txt",
        "",
        "Generated by write-for-humans-ais",
        "",
        "Pages:",
        ...pages.map((page) => `- ${page.title} (markdown/${path.basename(page.markdownPath)})`),
        "",
    ].join("\n");
    const llmsFullBlocks = pages.map((page) => {
        return [
            `# ${page.title}`,
            `Path: markdown/${path.basename(page.markdownPath)}`,
            "",
            page.markdown.trim(),
            "",
            "---",
            "",
        ].join("\n");
    });
    const llmsFull = ["# llms-full.txt", "", ...llmsFullBlocks].join("\n");
    const llmsPath = path.join(outDir, "llms.txt");
    const llmsFullPath = path.join(outDir, "llms-full.txt");
    await fs.writeFile(llmsPath, llms, "utf-8");
    await fs.writeFile(llmsFullPath, llmsFull, "utf-8");
    return [llmsPath, llmsFullPath];
}
async function writeClaims(outDir, inputDir) {
    const candidate = path.join(inputDir, "claims.jsonld");
    const dest = path.join(outDir, "claims.jsonld");
    try {
        const data = await fs.readFile(candidate, "utf-8");
        await fs.writeFile(dest, data, "utf-8");
    }
    catch {
        const skeleton = {
            "@context": "https://schema.org",
            "@graph": [],
        };
        await fs.writeFile(dest, JSON.stringify(skeleton, null, 2), "utf-8");
    }
    return dest;
}
async function writeManifest(outDir, outputFiles) {
    const manifest = {};
    for (const filePath of outputFiles) {
        const rel = path.relative(outDir, filePath).replace(/\\/g, "/");
        manifest[rel] = { sha256: await sha256File(filePath) };
    }
    const manifestPath = path.join(outDir, "manifest.json");
    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2), "utf-8");
    return manifestPath;
}
async function writeEval(outDir, inputDir, pages) {
    const questions = await loadQuestions(inputDir);
    const evalDir = path.join(outDir, "eval");
    await fs.mkdir(evalDir, { recursive: true });
    const reportPath = path.join(evalDir, "report.json");
    if (!questions || questions.length === 0) {
        const emptyReport = {
            generatedAt: new Date().toISOString(),
            totalQuestions: 0,
            averageCoverage: null,
            results: [],
        };
        await fs.writeFile(reportPath, JSON.stringify(emptyReport, null, 2), "utf-8");
        return reportPath;
    }
    const corpus = pages.map((page) => ({
        path: `markdown/${path.basename(page.markdownPath)}`,
        content: page.markdown,
    }));
    const report = runEval(questions, corpus);
    await fs.writeFile(reportPath, JSON.stringify(report, null, 2), "utf-8");
    return reportPath;
}
export async function buildSite(options) {
    const inputDir = path.resolve(options.inputDir);
    const outDir = path.resolve(options.outDir);
    await ensureEmptyDir(outDir, { inputDir, safetyRoot: options.safetyRoot, force: options.force });
    const pages = await buildPages(inputDir, outDir);
    const outputFiles = pages.map((p) => p.markdownPath);
    const llmsFiles = await writeLlmsFiles(outDir, pages);
    outputFiles.push(...llmsFiles);
    const claimsFile = await writeClaims(outDir, inputDir);
    outputFiles.push(claimsFile);
    if (options.runEval) {
        const evalReport = await writeEval(outDir, inputDir, pages);
        outputFiles.push(evalReport);
    }
    const manifestPath = await writeManifest(outDir, outputFiles);
    outputFiles.push(manifestPath);
    const fingerprint = sha256String(JSON.stringify(outputFiles.sort()));
    await fs.writeFile(path.join(outDir, "build.fingerprint"), `${fingerprint}\n`, "utf-8");
}
